package cn.dfinder.suggest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;

import net.sourceforge.pinyin4j.PinyinHelper;
import net.sourceforge.pinyin4j.format.HanyuPinyinCaseType;
import net.sourceforge.pinyin4j.format.HanyuPinyinOutputFormat;
import net.sourceforge.pinyin4j.format.HanyuPinyinToneType;
import net.sourceforge.pinyin4j.format.HanyuPinyinVCharType;
import net.sourceforge.pinyin4j.format.exception.BadHanyuPinyinOutputFormatCombination;

import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.analysis.TokenStream;
import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;
import org.apache.lucene.document.FieldType;
import org.apache.lucene.index.FieldInfo.IndexOptions;
import org.apache.lucene.document.StringField;
import org.apache.lucene.index.DirectoryReader;
import org.apache.lucene.index.IndexReader;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.index.IndexWriterConfig;
import org.apache.lucene.index.Term;
import org.apache.lucene.index.IndexWriterConfig.OpenMode;
import org.apache.lucene.search.BooleanClause;
import org.apache.lucene.search.BooleanQuery;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.ScoreDoc;
import org.apache.lucene.search.TermQuery;
import org.apache.lucene.store.AlreadyClosedException;
import org.apache.lucene.store.Directory;
import org.apache.lucene.util.Version;
import org.wltea.analyzer.lucene.IKAnalyzer;


/**
 * 
 * 参考Lucene {@link org.apache.lucene.search.spell.SpellChecker}
 * 
 * 
 * 
 *
 */
public class Suggestor implements java.io.Closeable {

  /**
   * The default minimum score to use, if not specified by calling {@link #setAccuracy(float)} .
   */
  public static final float DEFAULT_ACCURACY = 0.5f;

  /**
   * Field name for each word in the ngram index.
   */
  public static final String F_WORD = "word";
  
  /**
   * 默认boost值
   */
  public static final float DEFAULT_BOOST = 1f;

  /**
   * the spell index
   */
  // don't modify the directory directly - see #swapSearcher()
  // TODO: why is this package private?
  Directory spellIndex;
  /**
   * Boost value for start and end grams
   */
  private float bStart = 1.0f;

  private float bEnd = 1.0f;
  
  private float UNIBOOST = 1.0f/4;
  
  //private float pinyinBoost = 1.0f;
  // don't use this searcher directly - see #swapSearcher()

  private IndexSearcher searcher;
  /*
   * this locks all modifications to the current searcher.
   */

  private final Object searcherLock = new Object();
  /*
   * this lock synchronizes all possible modifications to the
   * current index directory. It should not be possible to try modifying
   * the same index concurrently. Note: Do not acquire the searcher lock
   * before acquiring this lock!
   */
  private final Object modifyCurrentIndexLock = new Object();

  private volatile boolean closed = false;
  
  // minimum score for hits generated by the spell checker query
  private float accuracy = DEFAULT_ACCURACY;

  
  private static HanyuPinyinOutputFormat pinFormat = new HanyuPinyinOutputFormat();
  public static final String PINYIN_FIELD_NAME = "py";
  public static final Analyzer pinyinAnalyzer = new IKAnalyzer(true);
  
  static {
	  pinFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);
	  pinFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);
	  pinFormat.setVCharType(HanyuPinyinVCharType.WITH_V);
  }


  /**
   * 使用spellIndex作为搜索建议的文件夹, 指定query搜索结果的最小的分为 {@link #DEFAULT_ACCURACY}
   * @param spellIndex The spelling index
   * @throws IOException if there is a problem opening the index
   */
  public Suggestor(Directory spellIndex) throws IOException {
    this(spellIndex, DEFAULT_ACCURACY);
  }
  
  public Suggestor(Directory spellIndex, float accuracy) throws IOException {
	    setSpellIndex(spellIndex);
	    this.accuracy = accuracy;
  }
  
  /**
   * Use a different index as the spell checker index or re-open
   * the existing index if <code>spellIndex</code> is the same value
   * as given in the constructor.
   * @param spellIndexDir the spell directory to use
   * @throws AlreadyClosedException if the Spellchecker is already closed
   * @throws  IOException if spellchecker can not open the directory
   */
  public final void  setSpellIndex(Directory spellIndexDir) throws IOException {
    // this could be the same directory as the current spellIndex
    // modifications to the directory should be synchronized 
    synchronized (modifyCurrentIndexLock) {
      ensureOpen();
      if (!DirectoryReader.indexExists(spellIndexDir)) {
		  IndexWriter writer = new IndexWriter(spellIndexDir,
             new IndexWriterConfig(Version.LUCENE_48, null));
          writer.close();
      }
      swapSearcher(spellIndexDir);
    }
  }


  /**
   * Sets the accuracy 0 &lt; minScore &lt; 1; default {@link #DEFAULT_ACCURACY}
   * @param acc The new accuracy
   */
  public void setAccuracy(float acc) {
    this.accuracy = acc;
  }

  /**
   * The accuracy (minimum score) to be used, unless overridden in {@link #suggestSimilar(String, int, IndexReader, String, SuggestMode, float)}, to
   * decide whether a suggestion is included or not.
   * @return The current accuracy setting
   */
  public float getAccuracy() {
    return accuracy;
  }

 
  /**
   * Suggest similar words.
   *
   * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms
   * is not the same as the edit distance strategy used to calculate the best
   * matching spell-checked word from the hits that Lucene found, one usually has
   * to retrieve a couple of numSug's in order to get the true best match.
   *
   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.
   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.
   *
   * @param word the word you want a spell check done on
   * @param numSug the number of suggested words
   * @param accuracy The minimum score a suggestion must have in order to qualify for inclusion in the results
   * @throws IOException if the underlying index throws an {@link IOException}
   * @throws AlreadyClosedException if the Spellchecker is already closed
   * @return String[]
   *
   * @see #suggestSimilar(String, int, IndexReader, String, SuggestMode, float)
   */
  public String[] suggestSimilar(String word, int numSug) throws IOException {
    return this.suggestSimilar(word, numSug, this.accuracy);
  }


  /**
   * 
   * Suggest similar words (optionally restricted to a field of an index).
   *
   * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms
   * is not the same as the edit distance strategy used to calculate the best
   * matching spell-checked word from the hits that Lucene found, one usually has
   * to retrieve a couple of numSug's in order to get the true best match.
   *
   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.
   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.
   *
   * @param word the word you want a spell check done on
   * @param numSug the number of suggested words
   * @param ir the indexReader of the user index (can be null see field param)
   * @param field the field of the user index: if field is not null, the suggested
   * words are restricted to the words present in this field.
   * @param suggestMode 
   * (NOTE: if indexReader==null and/or field==null, then this is overridden with SuggestMode.SUGGEST_ALWAYS)
   * @param accuracy The minimum score a suggestion must have in order to qualify for inclusion in the results
   * @throws IOException if the underlying index throws an {@link IOException}
   * @throws AlreadyClosedException if the Spellchecker is already closed
   * @return String[] the sorted list of the suggest words with these 2 criteria:
   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity
   * of the suggest words in the field of the user index
   * 
   */
  public String[] suggestSimilar(String word, int numSug, float accuracy) throws IOException {
    // obtainSearcher calls ensureOpen
    final IndexSearcher indexSearcher = obtainSearcher();
    try {
     
      BooleanQuery query = new BooleanQuery();
      
      addPinyinQuery(query, word);
      
      final int maxHits = 10 * numSug;
      final ScoreDoc[] hits = indexSearcher.search(query, null, maxHits).scoreDocs;
      final int stop = Math.min(hits.length, numSug);
      
      String [] list = new String[stop];
      for (int i = 0; i < stop; i++) {
    	// 剔除得分小于accuracy的结果  
    	if(hits[i].score < accuracy) {
    		continue;
    	}
    	final Document doc = indexSearcher.doc(hits[i].doc);
    	list[i] = doc.get(F_WORD);
     }
      	//当经过得分筛选后，可能会到之list中结果个数小雨list的长度，需要删除其中的null值
    	
        List<String> res = asRealValueList(list);
        return res.toArray(new String[0]);
    } finally {
      releaseSearcher(indexSearcher);
    }
  }
  
  
  /**
   * Add a clause to a boolean query.
   */
  private void add(BooleanQuery q, String name, String value, float boost) {
    Query tq = new TermQuery(new Term(name, value));
    tq.setBoost(boost);
    q.add(new BooleanClause(tq, BooleanClause.Occur.SHOULD));
  }
  

  private <E> List<E> asRealValueList(E[] arr){
	  List<E> arrList = new ArrayList<E>();
	  for(E e : arr) {
		  if(e != null) {
			  arrList.add(e);
		  }
	  }
	  return arrList;
  }

  /**
   * 给word分词
   * 中文+拼音
   * @param word
   * @return word中中文字的个数
   * @throws IOException 
   */
  private  int addPinyinQuery(BooleanQuery q, String word) throws IOException {
	  	List<String> tokens = new ArrayList<String>();
	  	int numofZh = 0;
	    TokenStream ts = pinyinAnalyzer.tokenStream("myfield", new StringReader(word));
	    CharTermAttribute term = ts.addAttribute(CharTermAttribute.class);
	    
	    ts.reset();
	    while(ts.incrementToken()){
	    	tokens.add(term.toString());
	    }
	    
	    ts.end();
	    ts.close();
	    
	    int tokensSize = tokens.size();
	    StringBuilder fl = new StringBuilder();
	    StringBuilder chinese= new StringBuilder();
	    for(int i = 0; i < tokensSize; i ++) {
		    final String s = tokens.get(i);
		    Character.UnicodeBlock ub = Character.UnicodeBlock.of(s
					.charAt(0));
		    // 判定当前串是中文
			if (ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS
					|| ub == Character.UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS
					|| ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A) {
				
				chinese.append(s);
				numofZh += s.length();
				
				if(fl.length() > 0) {
					//这种匹配只能匹配到长度小于四的首字母 再长会导致到gramk(k > 4)中搜索
	    			formGramQuery(q, fl.toString(), UNIBOOST);
	    			fl.delete(0, fl.length());//将首字母片段清空
				}
			} else {
				if(chinese.length() > 0) {
					formGramQuery(q, chinese.toString(), DEFAULT_BOOST);
					chinese.delete(0, chinese.length());
				}
				//是拼音
				if(s.length() == 1) {//只有一个字母 说明为首字母
		    		fl.append(s);
		    			} else {
 		    		add(q, PINYIN_FIELD_NAME, s, 1.5f * DEFAULT_BOOST);
		    		if(fl.length() > 0) {
		    			//add(q,"gram" + fl.length(), fl.toString(), fl.length() * DEFAULT_BOOST);
		    			//这种匹配只能匹配到长度小于四的首字母 再长会导致到gramk(k > 4)中搜索
		    			formGramQuery(q, fl.toString(), UNIBOOST);
		    			fl.delete(0, fl.length());//将首字母片段清空
		    		}
		    	} //pinyin end
			}
		}
	    
	    if(chinese.length() > 0) { //结尾中文
	    	formGramQuery(q, chinese.toString(), DEFAULT_BOOST);
	    }
		if( fl.length() > 0) {//结尾的首字母
			formGramQuery(q, fl.toString(), UNIBOOST);
		}
	    
				
		return numofZh;
	    
  } 
 
  /**
   * 生成NGram query
   * @param q
   * @param word
   * @param unigramBoost   unigram的搜索boost值<因为拼音首字母的unigram的意义很模糊，尤其对于首字母来说，需要单独指定>
 */
  private  void formGramQuery(BooleanQuery q, String word, float unigramBoost){
	  String[] grams;
      String key;
      int worldLen = word.length();
       for (int ng = getMin(worldLen); ng <= getMax(worldLen); ng++) {

        key = "gram" + ng; // form key

        grams = formGrams(word, ng); // form word into ngrams (allow dups too)

        if (grams.length == 0) {
          continue; // hmm
        }

        if (bStart > 0) { // should we boost prefixes?
        	final float startBoost = ng == 1 ? unigramBoost : bStart * ng;
          add(q, "start" + ng, grams[0], startBoost); // matches start of word

        }
        if (bEnd > 0) { // should we boost suffixes
         final float endBoost = ng == 1 ? unigramBoost : bEnd * ng;
          add(q, "end" + ng, grams[grams.length - 1], endBoost); // matches end of word

        }
        final float boost = ng == 1 ? unigramBoost : ng*DEFAULT_BOOST;
        for (int i = 0; i < grams.length; i++) {
          add(q, key, grams[i], boost);
        }
      }
  }
  /**
   * Form all ngrams for a given word.
   * @param text the word to parse
   * @param ng the ngram length e.g. 3
   * @return an array of all ngrams in the word and note that duplicates are not removed
   */
  private static String[] formGrams(String text, int ng) {
    int len = text.length();
    String[] res = new String[len - ng + 1];
    for (int i = 0; i < len - ng + 1; i++) {
      res[i] = text.substring(i, i + ng);
    }
    return res;
  }

  /**
   * Removes all terms from the spell check index.
   * @throws IOException If there is a low-level I/O error.
   * @throws AlreadyClosedException if the Spellchecker is already closed
   */
  public void clearIndex() throws IOException {
    synchronized (modifyCurrentIndexLock) {
      ensureOpen();
      final Directory dir = this.spellIndex;
	  final IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(
          Version.LUCENE_48, null)
          .setOpenMode(OpenMode.CREATE));
      writer.close();
      swapSearcher(dir);
    }
  }

  /**
   * Check whether the word exists in the index.
   * @param word word to check
   * @throws IOException If there is a low-level I/O error.
   * @throws AlreadyClosedException if the Spellchecker is already closed
   * @return true if the word exists in the index
   */
  public boolean exist(String word) throws IOException {
    // obtainSearcher calls ensureOpen
    final IndexSearcher indexSearcher = obtainSearcher();
    try{
      // TODO: we should use ReaderUtil+seekExact, we dont care about the docFreq
      // this is just an existence check
      return indexSearcher.getIndexReader().docFreq(new Term(F_WORD, word)) > 0;
    } finally {
      releaseSearcher(indexSearcher);
    }
  }

  /**
   * TODO 这个方法没有保证对已有索引的清除  需要手动将老的索引文件夹清空
   * TODO 如果需要索引的文件过大  要在索引一定数目后手动commit
   * Indexes the data from the given {@link Dictionary}.
   * @param config {@link IndexWriterConfig} to use
   * @param fullMerge whether or not the spellcheck index should be fully merged
   * @throws AlreadyClosedException if the Spellchecker is already closed
   * @throws IOException If there is a low-level I/O error.
   * @throws BadHanyuPinyinOutputFormatCombination 
 * @throws SQLException 
   */
  public final void updateSuggestIndex(BufferedReader in, IndexWriterConfig config, boolean fullMerge) throws IOException, BadHanyuPinyinOutputFormatCombination{
    synchronized (modifyCurrentIndexLock) {
      ensureOpen();
      final Directory dir = this.spellIndex;
      final IndexWriter writer = new IndexWriter(dir, config);
      String word;
      
	  while (( word = in.readLine()) != null) {
		
		int len = word.length();
		// ok index the word
		Document doc = createDocument(word, getMin(len), getMax(len));
		writer.addDocument(doc);
		}
	    if (fullMerge) {
	        writer.forceMerge(1);
	      }
	      // close writer
	      writer.close();
		}
  }
    	  

  private static int getMin(int l) {
/*    if (l > 5) {
      return 3;
    }
    if (l == 5) {
      return 2;
    }*/
    return 1;
  }

  private static int getMax(int l) {
    if (l > 5) {
      return 4;
    }
    if (l == 5) {
      return 3;
    }
    return 2;
  }

  private static Document createDocument(String text, int ng1, int ng2) throws BadHanyuPinyinOutputFormatCombination {
    Document doc = new Document();
    // the word field is never queried on... its indexed so it can be quickly
    // checked for rebuild (and stored for retrieval). Doesn't need norms or TF/pos
    Field f = new StringField(F_WORD, text, Field.Store.YES);
    doc.add(f); // orig term
    
    //拼音Unigram已经够用
    FieldType ft = new FieldType(StringField.TYPE_NOT_STORED);
    ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS);
    List<String> pys = getPinyin(text);
    for(String s : pys) {
        Field pyf = new Field(PINYIN_FIELD_NAME, s , ft);
        doc.add(pyf);
    }
    
    
    addGram(text, doc, ng1, ng2);
    
    return doc;
  }

  /**
   * 将给定text转换成拼音和首字母形式
   * @param text
   * @param doc
   * @param pinyin pinyin
   * @param firstLetters 首字母组合
   * @throws BadHanyuPinyinOutputFormatCombination
   */
  private static void getPinyingFirstLetters(String text, List<StringBuilder> firstLetters) throws BadHanyuPinyinOutputFormatCombination{
	  int len = text.length();
	  
	  for(int i = 0; i < len; i ++) {//将词中的每个字转换成py，然后使用whitespace analyzer
		  //TODO   尝试multivalue field;
		  String[] py = PinyinHelper.toHanyuPinyinStringArray(text.charAt(i), pinFormat);
		  int beforeAdd = firstLetters.size();
		  if( py == null ||py.length == 0){
			  continue;//遇见非中文字符
		  }
		  for(String p : py) {
			  //首字母
			  char first = p.charAt(0);
			  if(beforeAdd == 0) {
				  StringBuilder firstElement = new StringBuilder();
				  firstElement.append(first);
				  firstLetters.add(firstElement);
			  } else 
				  for(int j = 0; j < beforeAdd; j++) 
					  firstLetters.add(new StringBuilder(firstLetters.get(j)).append(first));
		  }
		  
		  //删除不包含当前char的首字母的串
		  for(int k = 0; k < beforeAdd; k++) 
			  firstLetters.remove(k);
	  }
  
  }
  
  /**
   * 获取给定文本的拼音
   * @param text
   * @return
   * @throws BadHanyuPinyinOutputFormatCombination
   */
  private static List<String> getPinyin(String text) throws BadHanyuPinyinOutputFormatCombination{
	  List<String> res = new ArrayList<String>();
	  for(int i = 0; i < text.length(); i ++) {
		  String[] py = PinyinHelper.toHanyuPinyinStringArray(text.charAt(i), pinFormat);
		  if(py == null || py.length == 0) {
			  continue;
		  }
		  for(String s : py) {
			  res.add(s);
		  }
	  }
	  return res;
  }
  private static void addGram(String text, Document doc, int ng1, int ng2) throws BadHanyuPinyinOutputFormatCombination {
    int len = text.length();
    for (int ng = ng1; ng <= ng2; ng++) {
      String key = "gram" + ng;
      String end = null;
      List<StringBuilder> endFirstLetters = null;
      for (int i = 0; i < len - ng + 1; i++) {
        String gram = text.substring(i, i + ng);
        FieldType ft = new FieldType(StringField.TYPE_NOT_STORED);
        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS);
        Field ngramField = new Field(key, gram, ft);
        
        
        // spellchecker does not use positional queries, but we want freqs
        // for scoring these multivalued n-gram fields.
        doc.add(ngramField);
        
        //change by tilney to add pinyin first letter support
        List<StringBuilder> firstLetters = new ArrayList<StringBuilder>();// 存放首字母
        getPinyingFirstLetters(gram, firstLetters);
        for(StringBuilder s : firstLetters) {
        //pinyin for ngram
            Field pyngField = new Field(key, s.toString(), ft);
            doc.add(pyngField);
        }
        
       
        
        if (i == 0) {
          // only one term possible in the startXXField, TF/pos and norms aren't needed.
          Field startField = new StringField("start" + ng, gram, Field.Store.NO);
          doc.add(startField);
          
          
          
          for(StringBuilder s : firstLetters) {
              //pinyin for ngram
              Field pystartField = new StringField("start" + ng, s.toString(), Field.Store.NO);
              doc.add(pystartField);
              }
        }
        end = gram;
        endFirstLetters = firstLetters;
      }
      if (end != null) { // may not be present if len==ng1
        // only one term possible in the endXXField, TF/pos and norms aren't needed.
        Field endField = new StringField("end" + ng, end, Field.Store.NO);
        doc.add(endField);
        if(endFirstLetters != null)
        for(StringBuilder s : endFirstLetters) {
            //pinyin for ngram
            Field pyendField = new StringField("end" + ng, s.toString(), Field.Store.NO);
            doc.add(pyendField);
            }
      }
    }
  }
  
  private IndexSearcher obtainSearcher() {
    synchronized (searcherLock) {
      ensureOpen();
      searcher.getIndexReader().incRef();
      return searcher;
    }
  }
  
  private void releaseSearcher(final IndexSearcher aSearcher) throws IOException{
      // don't check if open - always decRef 
      // don't decrement the private searcher - could have been swapped
      aSearcher.getIndexReader().decRef();      
  }
  
  private void ensureOpen() {
    if (closed) {
      throw new AlreadyClosedException("Spellchecker has been closed");
    }
  }
  
  /**
   * Close the IndexSearcher used by this SpellChecker
   * @throws IOException if the close operation causes an {@link IOException}
   * @throws AlreadyClosedException if the {@link SpellChecker} is already closed
   */
  public void close() throws IOException {
    synchronized (searcherLock) {
      ensureOpen();
      closed = true;
      if (searcher != null) {
        searcher.getIndexReader().close();
      }
      searcher = null;
    }
  }
  
  private void swapSearcher(final Directory dir) throws IOException {
    /*
     * opening a searcher is possibly very expensive.
     * We rather close it again if the Spellchecker was closed during
     * this operation than block access to the current searcher while opening.
     */
    final IndexSearcher indexSearcher = createSearcher(dir);
    synchronized (searcherLock) {
      if(closed){
        indexSearcher.getIndexReader().close();
        throw new AlreadyClosedException("Spellchecker has been closed");
      }
      if (searcher != null) {
        searcher.getIndexReader().close();
      }
      // set the spellindex in the sync block - ensure consistency.
      searcher = indexSearcher;
      this.spellIndex = dir;
    }
  }
  
  /**
   * Creates a new read-only IndexSearcher 
   * @param dir the directory used to open the searcher
   * @return a new read-only IndexSearcher
   * @throws IOException f there is a low-level IO error
   */
  // for testing purposes
  IndexSearcher createSearcher(final Directory dir) throws IOException{
    return new IndexSearcher(DirectoryReader.open(dir));
  }
  
  /**
   * Returns <code>true</code> if and only if the {@link SpellChecker} is
   * closed, otherwise <code>false</code>.
   * 
   * @return <code>true</code> if and only if the {@link SpellChecker} is
   *         closed, otherwise <code>false</code>.
   */
  boolean isClosed(){
    return closed;
  }
  
}
